// Code generated by easyjson for marshaling/unmarshaling. DO NOT EDIT.

package v2

import (
	json "encoding/json"
	common "github.com/act3-ai/hops/internal/apis/formulae.brew.sh/common"
	easyjson "github.com/mailru/easyjson"
	jlexer "github.com/mailru/easyjson/jlexer"
	jwriter "github.com/mailru/easyjson/jwriter"
)

// suppress unused package warning
var (
	_ *json.RawMessage
	_ *jlexer.Lexer
	_ *jwriter.Writer
	_ easyjson.Marshaler
)

func easyjsonBcda764DecodeGithubComAct3AiHopsInternalApisFormulaeBrewShV2(in *jlexer.Lexer, out *Tap) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "formulae":
			if in.IsNull() {
				in.Skip()
				out.Formulae = nil
			} else {
				in.Delim('[')
				if out.Formulae == nil {
					if !in.IsDelim(']') {
						out.Formulae = make([]*Formula, 0, 8)
					} else {
						out.Formulae = []*Formula{}
					}
				} else {
					out.Formulae = (out.Formulae)[:0]
				}
				for !in.IsDelim(']') {
					var v1 *Formula
					if in.IsNull() {
						in.Skip()
						v1 = nil
					} else {
						if v1 == nil {
							v1 = new(Formula)
						}
						(*v1).UnmarshalEasyJSON(in)
					}
					out.Formulae = append(out.Formulae, v1)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "casks":
			if in.IsNull() {
				in.Skip()
				out.Casks = nil
			} else {
				in.Delim('[')
				if out.Casks == nil {
					if !in.IsDelim(']') {
						out.Casks = make([]*Cask, 0, 8)
					} else {
						out.Casks = []*Cask{}
					}
				} else {
					out.Casks = (out.Casks)[:0]
				}
				for !in.IsDelim(']') {
					var v2 *Cask
					if in.IsNull() {
						in.Skip()
						v2 = nil
					} else {
						if v2 == nil {
							v2 = new(Cask)
						}
						(*v2).UnmarshalEasyJSON(in)
					}
					out.Casks = append(out.Casks, v2)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonBcda764EncodeGithubComAct3AiHopsInternalApisFormulaeBrewShV2(out *jwriter.Writer, in Tap) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"formulae\":"
		out.RawString(prefix[1:])
		if in.Formulae == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v3, v4 := range in.Formulae {
				if v3 > 0 {
					out.RawByte(',')
				}
				if v4 == nil {
					out.RawString("null")
				} else {
					(*v4).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"casks\":"
		out.RawString(prefix)
		if in.Casks == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v5, v6 := range in.Casks {
				if v5 > 0 {
					out.RawByte(',')
				}
				if v6 == nil {
					out.RawString("null")
				} else {
					(*v6).MarshalEasyJSON(out)
				}
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Tap) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonBcda764EncodeGithubComAct3AiHopsInternalApisFormulaeBrewShV2(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Tap) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonBcda764EncodeGithubComAct3AiHopsInternalApisFormulaeBrewShV2(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Tap) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonBcda764DecodeGithubComAct3AiHopsInternalApisFormulaeBrewShV2(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Tap) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonBcda764DecodeGithubComAct3AiHopsInternalApisFormulaeBrewShV2(l, v)
}
func easyjsonBcda764DecodeGithubComAct3AiHopsInternalApisFormulaeBrewShV21(in *jlexer.Lexer, out *CaskConflicts) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "cask":
			if in.IsNull() {
				in.Skip()
				out.Cask = nil
			} else {
				in.Delim('[')
				if out.Cask == nil {
					if !in.IsDelim(']') {
						out.Cask = make([]string, 0, 4)
					} else {
						out.Cask = []string{}
					}
				} else {
					out.Cask = (out.Cask)[:0]
				}
				for !in.IsDelim(']') {
					var v7 string
					v7 = string(in.String())
					out.Cask = append(out.Cask, v7)
					in.WantComma()
				}
				in.Delim(']')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonBcda764EncodeGithubComAct3AiHopsInternalApisFormulaeBrewShV21(out *jwriter.Writer, in CaskConflicts) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"cask\":"
		out.RawString(prefix[1:])
		if in.Cask == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v8, v9 := range in.Cask {
				if v8 > 0 {
					out.RawByte(',')
				}
				out.String(string(v9))
			}
			out.RawByte(']')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v CaskConflicts) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonBcda764EncodeGithubComAct3AiHopsInternalApisFormulaeBrewShV21(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v CaskConflicts) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonBcda764EncodeGithubComAct3AiHopsInternalApisFormulaeBrewShV21(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *CaskConflicts) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonBcda764DecodeGithubComAct3AiHopsInternalApisFormulaeBrewShV21(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *CaskConflicts) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonBcda764DecodeGithubComAct3AiHopsInternalApisFormulaeBrewShV21(l, v)
}
func easyjsonBcda764DecodeGithubComAct3AiHopsInternalApisFormulaeBrewShV22(in *jlexer.Lexer, out *Cask) {
	isTopLevel := in.IsStart()
	if in.IsNull() {
		if isTopLevel {
			in.Consumed()
		}
		in.Skip()
		return
	}
	in.Delim('{')
	for !in.IsDelim('}') {
		key := in.UnsafeFieldName(false)
		in.WantColon()
		if in.IsNull() {
			in.Skip()
			in.WantComma()
			continue
		}
		switch key {
		case "token":
			out.Token = string(in.String())
		case "full_token":
			out.FullToken = string(in.String())
		case "old_tokens":
			if in.IsNull() {
				in.Skip()
				out.OldTokens = nil
			} else {
				in.Delim('[')
				if out.OldTokens == nil {
					if !in.IsDelim(']') {
						out.OldTokens = make([]string, 0, 4)
					} else {
						out.OldTokens = []string{}
					}
				} else {
					out.OldTokens = (out.OldTokens)[:0]
				}
				for !in.IsDelim(']') {
					var v10 string
					v10 = string(in.String())
					out.OldTokens = append(out.OldTokens, v10)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "tap":
			out.Tap = string(in.String())
		case "name":
			if in.IsNull() {
				in.Skip()
				out.Name = nil
			} else {
				in.Delim('[')
				if out.Name == nil {
					if !in.IsDelim(']') {
						out.Name = make([]string, 0, 4)
					} else {
						out.Name = []string{}
					}
				} else {
					out.Name = (out.Name)[:0]
				}
				for !in.IsDelim(']') {
					var v11 string
					v11 = string(in.String())
					out.Name = append(out.Name, v11)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "desc":
			out.Desc = string(in.String())
		case "homepage":
			out.Homepage = string(in.String())
		case "url":
			out.URL = string(in.String())
		case "url_specs":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				out.URLSpecs = make(map[string]interface{})
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v12 interface{}
					if m, ok := v12.(easyjson.Unmarshaler); ok {
						m.UnmarshalEasyJSON(in)
					} else if m, ok := v12.(json.Unmarshaler); ok {
						_ = m.UnmarshalJSON(in.Raw())
					} else {
						v12 = in.Interface()
					}
					(out.URLSpecs)[key] = v12
					in.WantComma()
				}
				in.Delim('}')
			}
		case "appcast":
			if m, ok := out.Appcast.(easyjson.Unmarshaler); ok {
				m.UnmarshalEasyJSON(in)
			} else if m, ok := out.Appcast.(json.Unmarshaler); ok {
				_ = m.UnmarshalJSON(in.Raw())
			} else {
				out.Appcast = in.Interface()
			}
		case "version":
			out.Version = string(in.String())
		case "installed":
			out.Installed = string(in.String())
		case "installed_time":
			out.InstalledTime = string(in.String())
		case "bundle_version":
			out.BundleVersion = string(in.String())
		case "bundle_short_version":
			out.BundleShortVersion = string(in.String())
		case "outdated":
			out.Outdated = bool(in.Bool())
		case "sha256":
			out.Sha256 = string(in.String())
		case "artifacts":
			if in.IsNull() {
				in.Skip()
				out.Artifacts = nil
			} else {
				in.Delim('[')
				if out.Artifacts == nil {
					if !in.IsDelim(']') {
						out.Artifacts = make([]common.CaskArtifact, 0, 8)
					} else {
						out.Artifacts = []common.CaskArtifact{}
					}
				} else {
					out.Artifacts = (out.Artifacts)[:0]
				}
				for !in.IsDelim(']') {
					var v13 common.CaskArtifact
					if in.IsNull() {
						in.Skip()
					} else {
						in.Delim('{')
						v13 = make(common.CaskArtifact)
						for !in.IsDelim('}') {
							key := string(in.String())
							in.WantColon()
							var v14 []interface{}
							if in.IsNull() {
								in.Skip()
								v14 = nil
							} else {
								in.Delim('[')
								if v14 == nil {
									if !in.IsDelim(']') {
										v14 = make([]interface{}, 0, 4)
									} else {
										v14 = []interface{}{}
									}
								} else {
									v14 = (v14)[:0]
								}
								for !in.IsDelim(']') {
									var v15 interface{}
									if m, ok := v15.(easyjson.Unmarshaler); ok {
										m.UnmarshalEasyJSON(in)
									} else if m, ok := v15.(json.Unmarshaler); ok {
										_ = m.UnmarshalJSON(in.Raw())
									} else {
										v15 = in.Interface()
									}
									v14 = append(v14, v15)
									in.WantComma()
								}
								in.Delim(']')
							}
							(v13)[key] = v14
							in.WantComma()
						}
						in.Delim('}')
					}
					out.Artifacts = append(out.Artifacts, v13)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "caveats":
			if in.IsNull() {
				in.Skip()
				out.Caveats = nil
			} else {
				if out.Caveats == nil {
					out.Caveats = new(string)
				}
				*out.Caveats = string(in.String())
			}
		case "depends_on":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				out.DependsOn = make(map[string]common.CaskDependencies)
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v16 common.CaskDependencies
					if in.IsNull() {
						in.Skip()
					} else {
						in.Delim('{')
						v16 = make(common.CaskDependencies)
						for !in.IsDelim('}') {
							key := string(in.String())
							in.WantColon()
							var v17 []string
							if in.IsNull() {
								in.Skip()
								v17 = nil
							} else {
								in.Delim('[')
								if v17 == nil {
									if !in.IsDelim(']') {
										v17 = make([]string, 0, 4)
									} else {
										v17 = []string{}
									}
								} else {
									v17 = (v17)[:0]
								}
								for !in.IsDelim(']') {
									var v18 string
									v18 = string(in.String())
									v17 = append(v17, v18)
									in.WantComma()
								}
								in.Delim(']')
							}
							(v16)[key] = v17
							in.WantComma()
						}
						in.Delim('}')
					}
					(out.DependsOn)[key] = v16
					in.WantComma()
				}
				in.Delim('}')
			}
		case "conflicts_with":
			(out.ConflictsWith).UnmarshalEasyJSON(in)
		case "container":
			if m, ok := out.Container.(easyjson.Unmarshaler); ok {
				m.UnmarshalEasyJSON(in)
			} else if m, ok := out.Container.(json.Unmarshaler); ok {
				_ = m.UnmarshalJSON(in.Raw())
			} else {
				out.Container = in.Interface()
			}
		case "auto_updates":
			out.AutoUpdates = bool(in.Bool())
		case "deprecated":
			out.Deprecated = bool(in.Bool())
		case "deprecation_date":
			if in.IsNull() {
				in.Skip()
				out.DeprecationDate = nil
			} else {
				if out.DeprecationDate == nil {
					out.DeprecationDate = new(string)
				}
				*out.DeprecationDate = string(in.String())
			}
		case "deprecation_reason":
			if in.IsNull() {
				in.Skip()
				out.DeprecationReason = nil
			} else {
				if out.DeprecationReason == nil {
					out.DeprecationReason = new(string)
				}
				*out.DeprecationReason = string(in.String())
			}
		case "disabled":
			out.Disabled = bool(in.Bool())
		case "disable_date":
			if in.IsNull() {
				in.Skip()
				out.DisableDate = nil
			} else {
				if out.DisableDate == nil {
					out.DisableDate = new(string)
				}
				*out.DisableDate = string(in.String())
			}
		case "disable_reason":
			if in.IsNull() {
				in.Skip()
				out.DisableReason = nil
			} else {
				if out.DisableReason == nil {
					out.DisableReason = new(string)
				}
				*out.DisableReason = string(in.String())
			}
		case "TapGitHead":
			out.TapGitHead = string(in.String())
		case "languages":
			if in.IsNull() {
				in.Skip()
				out.Languages = nil
			} else {
				in.Delim('[')
				if out.Languages == nil {
					if !in.IsDelim(']') {
						out.Languages = make([]string, 0, 4)
					} else {
						out.Languages = []string{}
					}
				} else {
					out.Languages = (out.Languages)[:0]
				}
				for !in.IsDelim(']') {
					var v19 string
					v19 = string(in.String())
					out.Languages = append(out.Languages, v19)
					in.WantComma()
				}
				in.Delim(']')
			}
		case "ruby_source_path":
			out.RubySourcePath = string(in.String())
		case "ruby_source_checksum":
			if in.IsNull() {
				in.Skip()
			} else {
				in.Delim('{')
				out.RubySourceChecksum = make(map[string]string)
				for !in.IsDelim('}') {
					key := string(in.String())
					in.WantColon()
					var v20 string
					v20 = string(in.String())
					(out.RubySourceChecksum)[key] = v20
					in.WantComma()
				}
				in.Delim('}')
			}
		default:
			in.SkipRecursive()
		}
		in.WantComma()
	}
	in.Delim('}')
	if isTopLevel {
		in.Consumed()
	}
}
func easyjsonBcda764EncodeGithubComAct3AiHopsInternalApisFormulaeBrewShV22(out *jwriter.Writer, in Cask) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"token\":"
		out.RawString(prefix[1:])
		out.String(string(in.Token))
	}
	{
		const prefix string = ",\"full_token\":"
		out.RawString(prefix)
		out.String(string(in.FullToken))
	}
	{
		const prefix string = ",\"old_tokens\":"
		out.RawString(prefix)
		if in.OldTokens == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v21, v22 := range in.OldTokens {
				if v21 > 0 {
					out.RawByte(',')
				}
				out.String(string(v22))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"tap\":"
		out.RawString(prefix)
		out.String(string(in.Tap))
	}
	{
		const prefix string = ",\"name\":"
		out.RawString(prefix)
		if in.Name == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v23, v24 := range in.Name {
				if v23 > 0 {
					out.RawByte(',')
				}
				out.String(string(v24))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"desc\":"
		out.RawString(prefix)
		out.String(string(in.Desc))
	}
	{
		const prefix string = ",\"homepage\":"
		out.RawString(prefix)
		out.String(string(in.Homepage))
	}
	{
		const prefix string = ",\"url\":"
		out.RawString(prefix)
		out.String(string(in.URL))
	}
	{
		const prefix string = ",\"url_specs\":"
		out.RawString(prefix)
		if in.URLSpecs == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v25First := true
			for v25Name, v25Value := range in.URLSpecs {
				if v25First {
					v25First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v25Name))
				out.RawByte(':')
				if m, ok := v25Value.(easyjson.Marshaler); ok {
					m.MarshalEasyJSON(out)
				} else if m, ok := v25Value.(json.Marshaler); ok {
					out.Raw(m.MarshalJSON())
				} else {
					out.Raw(json.Marshal(v25Value))
				}
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"appcast\":"
		out.RawString(prefix)
		if m, ok := in.Appcast.(easyjson.Marshaler); ok {
			m.MarshalEasyJSON(out)
		} else if m, ok := in.Appcast.(json.Marshaler); ok {
			out.Raw(m.MarshalJSON())
		} else {
			out.Raw(json.Marshal(in.Appcast))
		}
	}
	{
		const prefix string = ",\"version\":"
		out.RawString(prefix)
		out.String(string(in.Version))
	}
	{
		const prefix string = ",\"installed\":"
		out.RawString(prefix)
		out.String(string(in.Installed))
	}
	{
		const prefix string = ",\"installed_time\":"
		out.RawString(prefix)
		out.String(string(in.InstalledTime))
	}
	{
		const prefix string = ",\"bundle_version\":"
		out.RawString(prefix)
		out.String(string(in.BundleVersion))
	}
	{
		const prefix string = ",\"bundle_short_version\":"
		out.RawString(prefix)
		out.String(string(in.BundleShortVersion))
	}
	{
		const prefix string = ",\"outdated\":"
		out.RawString(prefix)
		out.Bool(bool(in.Outdated))
	}
	{
		const prefix string = ",\"sha256\":"
		out.RawString(prefix)
		out.String(string(in.Sha256))
	}
	{
		const prefix string = ",\"artifacts\":"
		out.RawString(prefix)
		if in.Artifacts == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v26, v27 := range in.Artifacts {
				if v26 > 0 {
					out.RawByte(',')
				}
				if v27 == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
					out.RawString(`null`)
				} else {
					out.RawByte('{')
					v28First := true
					for v28Name, v28Value := range v27 {
						if v28First {
							v28First = false
						} else {
							out.RawByte(',')
						}
						out.String(string(v28Name))
						out.RawByte(':')
						if v28Value == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
							out.RawString("null")
						} else {
							out.RawByte('[')
							for v29, v30 := range v28Value {
								if v29 > 0 {
									out.RawByte(',')
								}
								if m, ok := v30.(easyjson.Marshaler); ok {
									m.MarshalEasyJSON(out)
								} else if m, ok := v30.(json.Marshaler); ok {
									out.Raw(m.MarshalJSON())
								} else {
									out.Raw(json.Marshal(v30))
								}
							}
							out.RawByte(']')
						}
					}
					out.RawByte('}')
				}
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"caveats\":"
		out.RawString(prefix)
		if in.Caveats == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.Caveats))
		}
	}
	{
		const prefix string = ",\"depends_on\":"
		out.RawString(prefix)
		if in.DependsOn == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v31First := true
			for v31Name, v31Value := range in.DependsOn {
				if v31First {
					v31First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v31Name))
				out.RawByte(':')
				if v31Value == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
					out.RawString(`null`)
				} else {
					out.RawByte('{')
					v32First := true
					for v32Name, v32Value := range v31Value {
						if v32First {
							v32First = false
						} else {
							out.RawByte(',')
						}
						out.String(string(v32Name))
						out.RawByte(':')
						if v32Value == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
							out.RawString("null")
						} else {
							out.RawByte('[')
							for v33, v34 := range v32Value {
								if v33 > 0 {
									out.RawByte(',')
								}
								out.String(string(v34))
							}
							out.RawByte(']')
						}
					}
					out.RawByte('}')
				}
			}
			out.RawByte('}')
		}
	}
	{
		const prefix string = ",\"conflicts_with\":"
		out.RawString(prefix)
		(in.ConflictsWith).MarshalEasyJSON(out)
	}
	{
		const prefix string = ",\"container\":"
		out.RawString(prefix)
		if m, ok := in.Container.(easyjson.Marshaler); ok {
			m.MarshalEasyJSON(out)
		} else if m, ok := in.Container.(json.Marshaler); ok {
			out.Raw(m.MarshalJSON())
		} else {
			out.Raw(json.Marshal(in.Container))
		}
	}
	{
		const prefix string = ",\"auto_updates\":"
		out.RawString(prefix)
		out.Bool(bool(in.AutoUpdates))
	}
	{
		const prefix string = ",\"deprecated\":"
		out.RawString(prefix)
		out.Bool(bool(in.Deprecated))
	}
	{
		const prefix string = ",\"deprecation_date\":"
		out.RawString(prefix)
		if in.DeprecationDate == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.DeprecationDate))
		}
	}
	{
		const prefix string = ",\"deprecation_reason\":"
		out.RawString(prefix)
		if in.DeprecationReason == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.DeprecationReason))
		}
	}
	{
		const prefix string = ",\"disabled\":"
		out.RawString(prefix)
		out.Bool(bool(in.Disabled))
	}
	{
		const prefix string = ",\"disable_date\":"
		out.RawString(prefix)
		if in.DisableDate == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.DisableDate))
		}
	}
	{
		const prefix string = ",\"disable_reason\":"
		out.RawString(prefix)
		if in.DisableReason == nil {
			out.RawString("null")
		} else {
			out.String(string(*in.DisableReason))
		}
	}
	{
		const prefix string = ",\"TapGitHead\":"
		out.RawString(prefix)
		out.String(string(in.TapGitHead))
	}
	{
		const prefix string = ",\"languages\":"
		out.RawString(prefix)
		if in.Languages == nil && (out.Flags&jwriter.NilSliceAsEmpty) == 0 {
			out.RawString("null")
		} else {
			out.RawByte('[')
			for v35, v36 := range in.Languages {
				if v35 > 0 {
					out.RawByte(',')
				}
				out.String(string(v36))
			}
			out.RawByte(']')
		}
	}
	{
		const prefix string = ",\"ruby_source_path\":"
		out.RawString(prefix)
		out.String(string(in.RubySourcePath))
	}
	{
		const prefix string = ",\"ruby_source_checksum\":"
		out.RawString(prefix)
		if in.RubySourceChecksum == nil && (out.Flags&jwriter.NilMapAsEmpty) == 0 {
			out.RawString(`null`)
		} else {
			out.RawByte('{')
			v37First := true
			for v37Name, v37Value := range in.RubySourceChecksum {
				if v37First {
					v37First = false
				} else {
					out.RawByte(',')
				}
				out.String(string(v37Name))
				out.RawByte(':')
				out.String(string(v37Value))
			}
			out.RawByte('}')
		}
	}
	out.RawByte('}')
}

// MarshalJSON supports json.Marshaler interface
func (v Cask) MarshalJSON() ([]byte, error) {
	w := jwriter.Writer{}
	easyjsonBcda764EncodeGithubComAct3AiHopsInternalApisFormulaeBrewShV22(&w, v)
	return w.Buffer.BuildBytes(), w.Error
}

// MarshalEasyJSON supports easyjson.Marshaler interface
func (v Cask) MarshalEasyJSON(w *jwriter.Writer) {
	easyjsonBcda764EncodeGithubComAct3AiHopsInternalApisFormulaeBrewShV22(w, v)
}

// UnmarshalJSON supports json.Unmarshaler interface
func (v *Cask) UnmarshalJSON(data []byte) error {
	r := jlexer.Lexer{Data: data}
	easyjsonBcda764DecodeGithubComAct3AiHopsInternalApisFormulaeBrewShV22(&r, v)
	return r.Error()
}

// UnmarshalEasyJSON supports easyjson.Unmarshaler interface
func (v *Cask) UnmarshalEasyJSON(l *jlexer.Lexer) {
	easyjsonBcda764DecodeGithubComAct3AiHopsInternalApisFormulaeBrewShV22(l, v)
}
